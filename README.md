# TP √† r√©aliser pour l'√©valuation

A faire en individuel obligatoirement üòá

**Le but n'est pas forc√©ment de tout terminer**, mais d'aller le plus loin possible pour chacun.

## Le sujet

Vous allez r√©aliser une application de gestion de locations de box de stockage √† destination des propri√©taires. Les locataires n'ont aucune connaissance de cet outil üò∂‚Äçüå´Ô∏è .

## Les fonctionnalit√©s

-   Authentification
-   Gestion de box (chaque compte utilisateur (= proprio de box) peut g√©rer ses propres box)
-   Gestion de locataires (nom, tel,mail, adresse, compte banciare...)
-   Gestion de mod√®les de contrats
-   Gestion des contrats automatis√©e : l'utilisateur peut cr√©er un mod√®le de contrat, en y incluant des variables (nom, prenom, adresse, etc...) qui seront par la suite automatiquement remplac√©es lors de la constitution d'un contrat.
-   Gestion des suivis de paiement au mois par mois (cases √† cocher)
-   Gestion des impots : en fonction des structures de soci√©t√©, perso ou autre, impl√©menter les calculs des impots et recracher les montants que vous devrez renseigner dans les cases de votre d√©claration d'imp√¥ts üòÅ
-   Gestion des factures

## Les petits plus

-   Export du contrat en PDF üòÅ (merci k√©vin)
-   Export des imp√¥ts en PDF (merci Yann)
-   Export Excel comptable des paiements re√ßu
-   Export des clients au format CSV
-   Envoi automatique par mail de la facture üê•

## Les imp√©ratifs

-   GIT & GITHUB (repo public)
-   Issues pour chaque chose r√©alis√©e
-   Milestones
-   Branches √† gogo üå¥

## Les livrables finaux

-   Code source
-   Script de d√©ploiement automatique (CI/CD)
-   URL d'acc√®s √† votre projet
-   Readme - qui inclura des logs de connexion par d√©faut pour tester l'application !

---

---

---

---

# Etapes de r√©alisation

1. Initialisation de Laravel
2. Mise en place de l'authentification (cf breeze : https://laravel.com/docs/11.x/starter-kits#laravel-breeze)

---

---

---

---

# Support de cours

Pr√©sentation de Laravel et bases

## Artisan

Artisan est une interface utilisable en ligne de commande (CLI - Command Line Interface).

### Utilisation de base

Artisan est bas√© sur PHP, et n√©cessite donc l'utilisation de la commande "PHP" pour s'en servir.
Toute commande artisan d√©bute donc par "php artisan".
La commande "php artisan" seule, affichera l'ensemble des commandes disponibles propos√©es par Artisan.

### Commandes usuelles

-   **Cr√©ation de fichiers** : Artisan nous permet de g√©n√©rer des fichiers a l'aide de la commande `php artisan make:...`. On doit ensuite interposer le symbole ":", puis sp√©cifier le type de fichier que l'on veut cr√©er.
    -   `php artisan make:model Nom`
    -   `php artisan make:controller NomController`
    -   `php artisan make:migration create_blog_table`
-   gestion de la base de donn√©es : Artisan nous permet de cr√©er, modifier ou supprimer des tables au sein d'une base de donn√©es. Il utilise les fichiers de migration, mais n'ex√©cute chaque migration, que sur les fichiers qui n'ont pas d√©j√† √©t√© migr√©s. Pour cela, il faut utiliser la commande "migrate".
    -   `php artisan migrate` : d√©clenche les migrations
    -   `php artisan migrate:fresh` : reset la BDD puis d√©clenche les migrations
    -   `php artisan migrate:fresh --seed` : reset la BDD puis d√©clenche les migrations et les seeders
-   gestion du cache : Artisan nous permet de nettoyer le cache de mani√®re rapide et simple avec la commande `php artisan cache:clear`.
-   Affichage des routes : Artisan nous permet d'afficher les routes existantes au sein de l'application avec la commande `php artisan route:list`.
-   publication des vendors : Artisan nous permet de publier les d√©pendances et librairies utilis√©es au sein d'un projet Laravel. Ceci nous permettant de modifier ces librairies et d√©pendances sans crainte de voir le travail perdue pour cause de mise √† jour. la commande √©tant `php artisan vendor:publish`

## Architecture de Laravel

|- /app  
|----- /Console  
|--------- /Commands : Dossier qui contient toutes les commandes personnalis√©es cr√©√©es.  
|----- /Exceptions  
|----- /Http  
|--------- /Controller : Dossier qui contiendra l'ensembe des controleurs  
|------------- controller.php : Controleur de base du framework  
|--------- /Middleware : Dossier qui contiendra l'ensemble des middleware  
|----- /Providers
|----- /Models
|--------- User.php : Mod√®le utilisateur g√©n√©r√© automatiquement par Laravel  
|- /bootstrap  
|- /config : Contient les fichiers de configuration de l'application  
|- /database  
|----- /factories : Contient les fichier de Factory
|----- /migrations : Contient les fichiers de migrations qui permettent de cr√©er, modifier ou supprimer une ou plusieurs table(s)  
|----- /seeders : Contient les fichier de Seeder
|- /public : dossier d'entr√©e de l'application  
|----- index.php : point d'entr√©e de l'application  
|- /ressources  
|----- /lang : dossier qui contient les fichiers de traductions de l'application  
|----- /views : dossier qui contient l'ensemble des vues du projet  
|- /routes
|----- web.php : fichier pour d√©clarer les routes relatives √† une application web.  
|- /storage  
|- /tests : dossier contenant les tests unitaires & fonctionnels  
|- /vendor : Contient l'ensemble des d√©pendances du projet (g√©r√© par Composer)  
|- composer.json => le fichier qui permet de lister les d√©pendances  
|- .env => fichier de configuration de l'application

## Etapes d'un CRUD

1. Cr√©ation d'une table en base de donn√©es :
    - Cr√©ation d'un ou plusieurs fichier(s) de migration avec la commande `php artisan make:migration [NOM_DU_FICHIER_DE_MIGRATION]`
    - Migration des fichiers gr√¢ce √† la commande `php artisan migrate`
2. Cr√©ation du mod√®le en lien avec la table cr√©√©e en base de donn√©es :
    - Cr√©ation du fichier avec la commande `php artisan make:model [NOM_DU_MODEL]`
    - Renseignement du nom de la table en lien avec le nouveau mod√®le gr√¢ce √† l'attribut : `protected $table="[NOM_DE_LA_TABLE]";`
    - Renseignement des champs de la table qui peuvent √™tre modifi√©s gr√¢ce au mod√®le via le tableau unidimensionnel contenu dans l'attribut `protected $fillable=[TABLEAU_DES_CHAMPS]`
3. (Optionnel mais recommand√©) Cr√©ation des Factory et impl√©mentation des seeders
    - Cr√©ation du factory avec la commande `php artisan make:factory [NOM_DU_FACTORY]`
    - impl√©mentation du tableau contenu dans le return du factory gr√¢ce √† la librairie faker (https://fakerphp.org/)
    - Mise en place de l'ex√©cution du factory dans le fichier `DatabaseSeeder` en sp√©cifiant le nombre de cr√©ation que vous souhaitez : `Blog::factory([NOMBRE_SOUHAITE])->create();`
4. Cr√©ation d'une ou plusieurs route(s)
    - Ajout de la / des route(s) dans le fichier `/routes/web.php`. Renseignement de l'URL attendue, du contr√¥leur ainsi que de sa m√©thode qui doit √™tre appel√©e au matching de l'URL, puis d√©finition d'un nom sur la route pour facilit√© son utilisation a posteriori.
5. Cr√©ation du contr√¥leur
    - Cr√©ation du fichier avec la commande `php artisan make:controller [NOM_DU_CONTROLLER]`
    - D√©finition de la / des m√©thode(s) en lien avec les routes pr√©c√©demment cr√©√©es
    - Penser √† retourner les vues ou les redirects √† l'issue de chaque m√©thode du controleur
6. Cr√©ation des vues
    - Pour chaque vue n√©cessaire, cr√©er un fichier avec l'extension `.blade.php` dans le dossier `/ressources/views/`. Nommer ce fichier de telle sorte √† pouvoir l'appeler simplement dans les m√©thodes des contr√¥leurs.

## Relations entre entit√©es

1. Ajouter une foreign key dans votre base de donn√©es pour lier une table "A" √† une table "B". Ajouter donc un champs "b_id" dans la table "A". Ensuite, d√©clarer votre foreign dans la migration gr√¢ce √† :

    ```
    # b_id est le nom de la colonne cr√©√©e dans la table repr√©sentant le lien vers l'autre table
    # unsigned() permet d'√©viter de nombreuses erreurs laravel
    # nullable() vous permet de ne pas rendre obligatoire le remplissage de ce champs.
    $table->bigInteger('b_id')->unsigned()->nullable();

    # le foreign('b_id') indique que c'est le champs 'b_id', cr√©√© juste au dessus, qui servira
    # de lien avec l'autre table.
    # references('id)->on('b') signifie que le champs 'b_id' va avoir comme r√©f√©rence (le champs qui va le li√© √† l'autre table) la colonne 'id', de la table 'b'
    $table->foreign('b_id')
        ->references('id')
        ->on('b');
    ```

2. D√©clarer cette relation dans vos models.

    - Ajouter le champs "b_id" dans l'attribut fillable du model "A"
    - d√©clarer dans le model "A", la relation avec le model "B", gr√¢ce au code suivant :

    ```
        # le nom de la m√©thode est arbitraire. Vous pouvez mettre ce que vous souhaitez, cependant c'est ce nom de m√©thode que vous devrez utiliser avec l'utilisation du "with" plus bas.
        public function b()
        {
            # BelongsTo doit prendre en premier param√®tre le nom du model A, puis en second param√®tre, le nom du champs dans le mod√®le courant li√© avec le model A gr√¢ce √† sa foreign key
            return $this->belongsTo(B::class, "b_id");
        }
    ```

    - Vous pouvez d√©clarer la fonction inverse dans l'autre model pour pouvoir acc√©der au "with" depuis l'autre model :

    ```
        # le nom de la m√©thode est arbitraire. Vous pouvez mettre ce que vous souhaitez, cependant c'est ce nom de m√©thode que vous devrez utiliser avec l'utilisation du "with" plus bas.
        public function as()
        {
            # la relation inverse se d√©clare grace a la m√©thode "hasMany", qui ne prend cette fois en param√®tre, que le nom du model "A"
            return $this->hasMany(A::class);
        }
    ```

3. Vous pouvez maintenant vous servir des m√©thodes "as" et "b" respectivement des mod√®les "B" et "A" gr√¢ce √† la m√©thode "with" d'Eloquent (d√©sormais votre ORM pr√©f√©r√©).
   Pour cela, vous pouvez par exemple faire l'une des requ√™tes suivantes :

```
    # Renverra a la fois le model A, en y incluant dans les relations, l'objet "B" correspondant en base de donn√©es
    $obj = A::where('id', $id)->with('b')->first();

    # Renverra a la fois le model B, en y incluant dans les relations, le ou les objets "A" correspondant(s) en base de donn√©es
    $obj = B::where('id', $id)->with('as')->first();
```
